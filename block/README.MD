## 位运算
在程序中用的位运算符一般有 `&`  `|` `^` `~` `>>` `<<` `+`（加法好像不叫位操作，把它看成位操作）
可以将这些位操作分为两大类：
1. `&` `|` `^` `~`
2. `>>` `<<` `+`

第一类位运算的结果不会产生进位以及移位，也就是说全部位同时执行一次位运算和全部位分块执行多次位运算得到的结果是一样的。
比如下面的二进制（右侧为低位）：

**整体运算一次，结果为：1001**

|   | 第一次 |
|:- |:-- |
|   | 1101 |
| & | 1011 |
| = | 1001 |

**分块运算两次，结果为：1001**

|   | 第二次 | 第一次 |
|:--|:-- |:--|
|   | 11 | 01 |
| & | 10 | 11 |
| = | 10 | 01 |


第二类位运算会产生进位以及移位，全部同时执行和多次分块执行的结果可能会产生差异。比如下面的二进制(右侧为低位，省略了溢出位)：

**整体运算一次，结果为：1000**

|   | 第一次 |
|:- |:-----|
|   | 1101 |
| + | 1011 |
| = | 1000|

**分块运算两次，结果为：0100**

|   | 第二次 | 第一次 |
|:--|:--|:--|
|   |  11 |  01 |
| + |  10 |  11 |
| = |  01 |  00 |

所以第一类位运算对分块处理长序列没有影响，第二类则有影响。为了消除分块运算的影响，需要将第一次运算的进位保存下来，在进行第二次运算额的结果上加上第一次运算的进位(省略溢出位)： `11+10+01 = 10`。所以分块时主要处理加法以及左移。

## 左移
左移会产生向高位的移位，在分块处理的时候要把第n个block的左移保存下来。作为第n+1个block的最低位。假设只有一个整形只有4位，现在要处理12位的左移，要分成3个block处理，假设二进制序列（右侧位低位）为：
```
原始的：  1110 0001 1101
左移后：  1100 0011 1010
```
下面是移位过程
1. 左移第一个block
  ```
   1.右移三位（这里使用的是一个copy），获得最高位的值，并且保存
      1101 右移三位 = 0001
   2. 左移一位
      1101 左移一位 = 1010
   3. 与 前一个block的移位进行 or 操作，这里因为没有前一个，所以和0进行相或
      1010 or 0000 = 1010
   4. 保存结果
      arr[0] = 1010
  ```
2. 左移第二个block
  ```
   1. 右移三位，获得最高位的值，并且保存
      0001 右移三位 = 0000
   2. 左移一位
      0001 左移一位 = 0010
   3. 与第一个block 的移位进行 or 操作
      0010 or 0001  = 0011
   4. 保存结果
      arr[1] = 0011
  ```
3. 左移第三个block
  ```
   1. 右移三位，获得最高位的值，并且保存（这步没用了，但是循环里还是会执行）
      1110 右移三位 = 0001
   2. 左移一位
      1110 左移一位 = 1100
   3. 与第二个block 的移位进行 or 操作
      1100 or 0000  = 1100
   4. 保存结果
      arr[2] = 1100
  ```

arr里就是移位后的结果
 ```
 arr[2]  arr[1]  arr[0]
 1100    0011    1010
 ```

## 加法
加法和移位的处理流程类似，但有一点不同--进位，现在只有KNC支持进位加法，下面先说一下普通不带进位的加法（CPU、SSE和KNL支持的加法）。

### 普通加法
普通加法就是我们常用的加法，会自动抛弃进位，如下面（右位为低位，假设整形只有4位）
```
1100 + 1100 = 1000
```
实际结果应该为`11000`，但是最左侧的 1 （也就是进位，carry bit）会被扔掉。但是在分block计算时，我们必须要得到这个进位的1，将这个进位与下一个block的和相加，所以为了取的进位，我们必须牺牲一个位，作为缓冲位，也就是说对于4位的int来说，后三位作为有效位，最高位作为缓冲位。看下面的例子：
```
   1001 1100 0110
+  0111 1011 1100
=  0001 1000 0010
```
首先因为使用最高位作为缓冲位，所以分block计算的时候，必须重新排列一下，使每个block只包含3个有效位
```
100 111 000 110
011 110 111 100
```
将最高位补为0，就变成下面的样子
```
0100 0111 0000 0110
0011 0110 0111 0100
```
下面是计算过程
1. 将第一个block中的两个数相加
   ```
   1. 将两个数相加，获得sum
      0110 + 0100 = 1010
   2. 将sum与前一个block的进位相加，这里没有前一个，所以和0相加
      1010 + 0000 = 1010
   3. 将sum（使用的是sum的一个copy）右移三位，获得最高位的值（也就是进位）并且保存
      1010 右移三位 = 0001
   4. 保存sum
      arr[0] = 1010
   ```
2. 将第二个block中的两个数相加
  ```
   1. 将两个数相加，获得sum
      0000 + 0111 = 0111
   2. 将sum和第一个block的进位相加
      0111 + 0001 = 1000
   3. 将sum右移三位，获得最高位的值并且保存
      1000 右移三位 = 0001
   4. 保存sum
      arr[1] = 1000
  ```
3. 将第三个block中的两个数相加
    ```
    1. 将两个数相加，获得sum
       0111 + 0110 = 1101
    2. 将sum和第一个block的进位相加
       1101 + 0001 = 1110
    3. 将sum右移三位，获得最高位的值并且保存
       0110 右移三位 = 0001
    4. 保存sum
       arr[2] = 1110
    ```
4. 将第四个block中的两个数相加
  ```
  1. 将两个数相加，获得sum
     0100 + 0011 = 0111
  2. 将sum和第一个block的进位相加
     0111 + 0001 = 1000
  3. 将sum右移三位，获得最高位的值并且保存（这步没用了，但循环里还是会执行）
     1001 右移三位 = 0001
  4. 保存sum
     arr[3] = 1000
  ```

最后得到的数组
```
arr[3] arr[2] arr[1] arr[0]
1000   0110   1000   1010
```
去掉最高位
```
000 110 000 010
```
重组
```
0001 1000 0010
```
#### 缓冲位带来的问题

1. 可用的位长度减少了一个。32位的 int 只能使用31位

2. 位操作变多了。在上面得到 arr 数组里，如果还需要对这个数组进行左移操作（确实需要），必须多加一个 and 操作。

看上面得到的arr数组，以 `arr[0] = 1010` 为例，因为最高位作为缓冲位了，所以次高位变为名义上的最高位了。现在我们需要得到次高位的值，因此只需要右移两位
```
1010 右移两位 = 0010
```
这时候缓冲位的1来捣乱了，所以移位之前我们需要将最高位的值置为0，使用下面的方法
```
1010 & 0111 = 0010
```
这时候再右移就可以得到正确的值了
```
0010 右移两位 0000
```

### 进位加法
普通的加法之所以要使用缓冲位，是因为会丢弃最高位相加得到的进位，但是在KNC上我们可以使用进位加法来解决这个问题
```
__m512i _mm512_adc_epi32 (__m512i v2, __mmask16 k2, __m512i v3, __mmask16 * k2_res)
```
这个函数会执行`v2+v3+k2`，其中k2就是上一次运算的进位数据，本次运算的进位会保存到 `k2_res` 里。

### 不同加法对性能的影响
在myers和bitpal (0, -1, -1)，总共需要的位操作数也就20-30个，由于缓冲位带来的额外 `and` 操作（只要有左移操作就会有额外的一次 `and` 操作）大概有3-4个，对性能有一定的影响。carry加法的性能大概是普通加法的1.08 - 1.21 倍。
